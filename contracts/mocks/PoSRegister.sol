// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/**
* This is a fake empty contract for testing purpose.
*/ 
contract MockPoSRegister {

  mapping(address => bytes32) private addressToIdentifierMap;
  mapping(bytes32 => address) private identifierToAddressMap;

  mapping(address => uint64) private userVotes;
  mapping(address => uint64) private userUnlockedVotes;

  /* function _addressToBytes(address a) public pure returns (bytes memory b){
    assembly {
        let m := mload(0x40)
        a := and(a, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
        mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))
        mstore(0x40, add(m, 52))
        b := m
    }
  } */

  /**
     * @dev Register PoS account
     * @param indentifier - PoS account address to register
     * @param votePower - votes count
     * @param blsPubKey - BLS public key
     * @param vrfPubKey - VRF public key
     * @param blsPubKeyProof - BLS public key's proof of legality, used to against some attack, generated by conflux-rust fullnode
     */
    function register(
        bytes32 indentifier,
        uint64 votePower,
        bytes calldata blsPubKey,
        bytes calldata vrfPubKey,
        bytes[2] calldata blsPubKeyProof
    ) public {
      // bytes32 _identifier = keccak256(_addressToBytes(msg.sender));
      addressToIdentifierMap[msg.sender] = indentifier;
      identifierToAddressMap[indentifier] = msg.sender;
      emit Register(indentifier, blsPubKey, vrfPubKey);
    }

    /**
     * @dev Increase specified number votes for msg.sender
     * @param votePower - count of votes to increase
     */
    function increaseStake(uint64 votePower) public {
      userVotes[msg.sender] += votePower;
      emit IncreaseStake(addressToIdentifierMap[msg.sender], votePower);
    }

    /**
     * @dev Retire specified number votes for msg.sender
     * @param votePower - count of votes to retire
     */
    function retire(uint64 votePower) public {
      // TODO add delay seven days logic
      userUnlockedVotes[msg.sender] += votePower;
      emit Retire(addressToIdentifierMap[msg.sender], votePower);
    }

    /**
     * @dev Query PoS account's lock info. Include "totalStakedVotes" and "totalUnlockedVotes"
     * @param identifier - PoS address
     */
    function getVotes(bytes32 identifier) public view returns (uint256, uint256) {
      address _address = identifierToAddressMap[identifier];
      return (userVotes[_address], userUnlockedVotes[_address]);
    }

    /**
     * @dev Query the PoW address binding with specified PoS address
     * @param identifier - PoS address
     */
    function identifierToAddress(bytes32 identifier) public view returns (address) {
      return identifierToAddressMap[identifier];
    }

    /**
     * @dev Query the PoS address binding with specified PoW address
     * @param addr - PoW address
     */
    function addressToIdentifier(address addr) public view returns (bytes32) {
      return addressToIdentifierMap[addr];
    }

    /**
     * @dev Emitted when register method executed successfully
     */
    event Register(bytes32 indexed identifier, bytes blsPubKey, bytes vrfPubKey);

    /**
     * @dev Emitted when increaseStake method executed successfully
     */
    event IncreaseStake(bytes32 indexed identifier, uint64 votePower);

    /**
     * @dev Emitted when retire method executed successfully
     */
    event Retire(bytes32 indexed identifier, uint64 votePower);
}
